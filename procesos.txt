
En este archivo están guardados los procesos para los inputs ppvm y pload, los dos más complejos

---------------------------------------------------------------
Para ppvm
---------------------------------------------------------------
47:15, /*If ppvm >= 15, skip next*/
33:0, /*Reset to 0*/
1:$feed_id(ppv), /*Log to feed ppv*/
5:$feed_id(ppv), /*A partir de ppv usando el engine Power to kWh/d */
1:$feed_id(eDPv), /*Log to feed eDPv*/
4:$feed_id(ppv),	/*A partir de ppv usando el engine Power to kWh*/
1:$feed_id(tPv), /*Log to feed tPv*/
33:0, /*Reset to 0*/
29:$feed_id(ppv), /*Sumas ppv, para dejarlo como ppv, como estaba al pincipio*/
25:0, /*Allow negative*/
22:$input_id(pload), /*ppv - pload (Problema porque creo que hay que predecir el id del input de pload sumando dos al de ppvm)*/
47:0, /*If (ppv - pload) >= 0, skip next*/
33:0, /*Reset to 0*/
1:$feed_id(IPvToNet) /*Log to IPvToNet, antes que iPvToLoad, es la unica forma que he visto de hacerlo secuencial. Creo que equivale a lo que está puesto, pues este valor solo puede valer o 0 o la diferenciappv-pload que tenemos en el buffer, y creo que así se resuelve el if de orma correcta. Más adelante se repite ésta técnica*/
5:$feed_id(IPvToNet) /*A partir de IPvToNet usando el engine Power to kWh/d*/
1:$feed_id(eDPvToNet) /*Log to eDPvToNet*/
33:0, /*Reset to 0*/
29:$feed_id(eDPv), /*Sumas eDPv*/
30:$feed_id(eDPvToNet), /*Restas eDPvToNet*/
1:$feed_id(Log to eDLoadFromPv), /*Log to eDLoadFromPv*/
2:100, /*Por 100*/
32:$feed_id(eDPv), /*entre eDPv*/
1:$feed_id(dPSelf), /*Log to dPSelf*/
33:0, /*Reset to 0*/
29:$feed_id(eDLoadFromPv), /*Sumas eDLoadFromPv*/
2:100, /*Por 100*/
32:$feed_id(eDLoad), /*entre eDLoad*/
1:$feed_id(dPLoadFromPv) /*Log to dPLoadFromPv*/


---------------------------------------------------------------
Para pload
---------------------------------------------------------------
5:$feed_id(pload) /*A partir de pload usando el engine Power to kWh/d*/
1:$feed_id(eDLoad), /*Log to feed eDLoad*/
4:$feed_id(pload)	/*A partir de pload usando el engine Power to kWh*/
1:$feed_id(tLoad), /*Log to feed eDLoad*/
37:0, /*Reset to Original, no veo otra forma de volver al input inicial, salvo sumar el input que estamos insertando, cosa que me mosquea, aunque más adelante hago algo parecido con una división*/
25:0, /*Allow negative*/
30:$feed_id(ppv), /*pload - ppv*/
46:0, /*If (pload - ppv) > 0, skip next*/
33:0, /*Reset to 0*/
1:$feed_id(iGridToLoad) /*Log to iGridToLoad, antes que iPvToLoad, es la unica forma que he visto de hacerlo secuencial. Creo que equivale a lo que está puesto*/
37:0, /*Reset to Original*/
30:$feed_id(iGridToLoad), /*Resto iGridToLoad para recuperar iPvToLoad*/
1:$feed_id(iPvToload), /*Log to iPvToLoad*/
2:100, /*Se multiplica por 100*/
12:$input_id(pload), /*Se divide entre pload*/
1:$feed_id(iPLoadFromPv), /*Log to iPLoadFromPv*/
33:0, /*Reset to 0*/
29:$feed_id(iGridToload), /*Se le suma el valor iGridToload para asignar ese valor*/
2:100, /*De nuevo, se multiplica por 100*/
12:$input_id(pload), /*Se divide entre pload*/
1:$feed_id(iPLoadFromNet), /*Log to iPLoadFromNet*/
33:0, /*Reset to 0*/
29:$feed_id(iGridToload), /*Se le suma el valor iGridToload para asignar ese valor*/
5:$feed_id(iGridToload) /*A partir de iGridToload usando el engine Power to kWh/d*/
1:$feed_id(eDNet), /*Log to feed eDNet*/
33:0, /*Reset to 0*/
29:$feed_id(iGridToload), /*Se le suma el valor iGridToload para asignar ese valor*/
4:$feed_id(iGridToload) /*A partir de iGridToload usando el engine Power to kWh*/
1:$feed_id(tLoadFromNet), /*Log to feed tLoadFromNet*/
33:0, /*Reset to 0*/
29:$feed_id(iPvToLoad), /*Se le suma el valor iPvToLoad para asignar ese valor*/
4:$feed_id(iPvToLoad) /*A partir de iPvToLoad usando el engine Power to kWh*/
1:$feed_id(tPvToLoad), /*Log to feed tPvToLoad*/
33:0, /*Reset to 0*/
29:$feed_id(tPv), /*Se le suma el valor tPv para asignar ese valor*/
30:$feed_id(tPvToLoad), /*Se le suma el valor tPvToLoad*/
1:$feed_id(tPvToNet) /*Log to feed tPvToNet*/

